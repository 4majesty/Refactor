package org.eclipse.jdt.internal.corext.refactoring.generics;

import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.eclipse.core.runtime.Assert;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.CharacterLiteral;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.IBinding;
import org.eclipse.jdt.core.dom.IMethodBinding;
import org.eclipse.jdt.core.dom.ITypeBinding;
import org.eclipse.jdt.core.dom.IVariableBinding;
import org.eclipse.jdt.core.dom.Javadoc;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.internal.corext.dom.ASTNodes;
import org.eclipse.jdt.internal.corext.dom.Bindings;
import org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor;
import org.eclipse.jdt.internal.corext.refactoring.rename.MethodChecks;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.GenericType;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.ParameterizedType;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TType;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TypeVariable;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.WildcardType;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.ArrayElementVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.CollectionElementVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.ConstraintVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.ImmutableTypeVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.IndependentTypeVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.ParameterTypeVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.ParameterizedTypeVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.ReturnTypeVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.TTypes;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.TypeVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.VariableVariable2;
import org.eclipse.jdt.internal.corext.util.JdtFlags;

public class InferTypeArgumentsConstraintCreator extends HierarchicalASTVisitor implements IInferTypeArgumentsConstraintCreator {
	/** 
	* Property in <code>ASTNode</code>s that holds the node's <code>ConstraintVariable</code>.
	*/
	private static final String CV_PROP= "org.eclipse.jdt.internal.corext.refactoring.typeconstraints.CONSTRAINT_VARIABLE";

	private InferTypeArgumentsTCModel fTCModel;

	private ICompilationUnit fCU;

	private final boolean fAssumeCloneReturnsSameType;

	public InferTypeArgumentsConstraintCreator(InferTypeArgumentsTCModel model, boolean assumeCloneReturnsSameType) {
		fTCModel= model;
		fAssumeCloneReturnsSameType= assumeCloneReturnsSameType;
	}

	@Override
	public boolean visit(CompilationUnit node) {
		fTCModel.newCu();
		fCU= (ICompilationUnit)node.getJavaElement();
		return super.visit(node);
	}

	@Override
	public boolean visit(Javadoc node) {
		return false;
	}

	@Override
	public boolean visit(Type node) {
		return false;
	}

	@Override
	public void endVisit(Type node) {
		if (node.isParameterizedType()) {
			ImmutableTypeVariable2 typeVariable= fTCModel.makeImmutableTypeVariable(node.resolveBinding(), null);
			setConstraintVariable(node, typeVariable);
		} else {
			TypeVariable2 typeVariable= fTCModel.makeTypeVariable(node);
			setConstraintVariable(node, typeVariable);
		}
	}

	@Override
	public void endVisit(SimpleName node) {
		if (node.resolveBoxing()) {
			ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(node.resolveTypeBinding(), node);
			setConstraintVariable(node, boxed);
			return;
		}
		IBinding binding= node.resolveBinding();
		if (binding instanceof IVariableBinding) {
			IVariableBinding variableBinding= (IVariableBinding)binding;
			ITypeBinding declaredVariableType= variableBinding.getVariableDeclaration().getType();
			if (declaredVariableType.isTypeVariable()) {
				Expression receiver= getSimpleNameReceiver(node);
				if (receiver != null) {
					ConstraintVariable2 receiverCv= getConstraintVariable(receiver);
					Assert.isNotNull(receiverCv);
					ConstraintVariable2 elementCv= fTCModel.getElementVariable(receiverCv, declaredVariableType);
					setConstraintVariable(node, elementCv);
					return;
				}
			} else if (declaredVariableType.isParameterizedType()) {
				Expression receiver= getSimpleNameReceiver(node);
				if (receiver != null) {
					ConstraintVariable2 receiverCv= getConstraintVariable(receiver);
					if (receiverCv != null) {
						ConstraintVariable2 returnTypeCv= fTCModel.makeParameterizedTypeVariable(declaredVariableType);
						setConstraintVariable(node, returnTypeCv);
						TType declaredVariableTType= fTCModel.createTType(declaredVariableType);
						fTCModel.createTypeVariablesEqualityConstraints(receiverCv, Collections.EMPTY_MAP, returnTypeCv, declaredVariableTType);
						return;
					}
				}
			} else {
			}
			VariableVariable2 cv= fTCModel.makeVariableVariable(variableBinding);
			setConstraintVariable(node, cv);
		}
	}

	private Expression getSimpleNameReceiver(SimpleName node) {
		Expression receiver;
		if (node.getParent() instanceof QualifiedName && node.getLocationInParent() == QualifiedName.NAME_PROPERTY) {
			receiver= ((QualifiedName)node.getParent()).getQualifier();
		} else if (node.getParent() instanceof FieldAccess && node.getLocationInParent() == FieldAccess.NAME_PROPERTY) {
			receiver= ((FieldAccess)node.getParent()).getExpression();
		} else {
			receiver= null;
		}
		if (receiver instanceof ThisExpression)
			return null;
		else
			return receiver;
	}

	@Override
	public void endVisit(FieldAccess node) {
		if (node.resolveBoxing()) {
			ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(node.resolveTypeBinding(), node);
			setConstraintVariable(node, boxed);
			return;
		}
		ConstraintVariable2 nameCv= getConstraintVariable(node.getName());
		setConstraintVariable(node, nameCv);
	}

	@Override
	public void endVisit(QualifiedName node) {
		if (node.resolveBoxing()) {
			ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(node.resolveTypeBinding(), node);
			setConstraintVariable(node, boxed);
			return;
		}
		ConstraintVariable2 cv= getConstraintVariable(node.getName());
		setConstraintVariable(node, cv);
	}

	@Override
	public void endVisit(ArrayAccess node) {
		if (node.resolveBoxing()) {
			ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(node.resolveTypeBinding(), node);
			setConstraintVariable(node, boxed);
			return;
		}
		ConstraintVariable2 arrayCv= getConstraintVariable(node.getArray());
		if (arrayCv == null)
			return;
		ArrayElementVariable2 arrayElementCv= fTCModel.getArrayElementVariable(arrayCv);
		setConstraintVariable(node, arrayElementCv);
	}

	@Override
	public void endVisit(Assignment node) {
		Expression lhs= node.getLeftHandSide();
		Expression rhs= node.getRightHandSide();
		ConstraintVariable2 left= getConstraintVariable(lhs);
		ConstraintVariable2 right= getConstraintVariable(rhs);
		if (node.resolveBoxing()) {
			ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(node.resolveTypeBinding(), node);
			setConstraintVariable(node, boxed);
		} else {
			setConstraintVariable(node, left);
		}
		if (left == null || right == null)
			return;
		Assignment.Operator op= node.getOperator();
		if (op == Assignment.Operator.PLUS_ASSIGN && (lhs.resolveTypeBinding() == node.getAST().resolveWellKnownType("java.lang.String"))) {
		} else {
			fTCModel.createElementEqualsConstraints(left, right);
			fTCModel.createSubtypeConstraint(right, left);
		}
	}

	@Override
	public void endVisit(CastExpression node) {
		Type type= node.getType();
		ITypeBinding typeBinding= type.resolveBinding();
		if (typeBinding.isPrimitive()) {
			ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(typeBinding, node);
			setConstraintVariable(node, boxed);
			return;
		}
		ConstraintVariable2 typeCv= getConstraintVariable(type);
		if (typeCv == null)
			return;
		setConstraintVariable(node, typeCv);
		Expression expression= node.getExpression();
		ConstraintVariable2 expressionCv= getConstraintVariable(expression);
		if (expressionCv == null)
			return;
		if (expressionCv instanceof ImmutableTypeVariable2)
			return;
		if (!(expressionCv instanceof TypeVariable2 || expressionCv instanceof IndependentTypeVariable2 || expressionCv instanceof CollectionElementVariable2)
				&& fTCModel.getElementVariables(expressionCv).size() == 0 && fTCModel.getArrayElementVariable(expressionCv) == null)
			return;
		fTCModel.createAssignmentElementConstraints(typeCv, expressionCv);
		if (expression instanceof MethodInvocation) {
			MethodInvocation invoc= (MethodInvocation)expression;
			if (!isSpecialCloneInvocation(invoc.resolveMethodBinding(), invoc.getExpression())) {
				fTCModel.makeCastVariable(node, expressionCv);
			}
		} else {
			fTCModel.makeCastVariable(node, expressionCv);
		}
		boolean eitherIsIntf= typeBinding.isInterface() || expression.resolveTypeBinding().isInterface();
		if (eitherIsIntf)
			return;
	}

	@Override
	public void endVisit(ParenthesizedExpression node) {
		if (node.resolveBoxing()) {
			ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(node.resolveTypeBinding(), node);
			setConstraintVariable(node, boxed);
			return;
		}
		ConstraintVariable2 expressionCv= getConstraintVariable(node.getExpression());
		setConstraintVariable(node, expressionCv);
	}

	@Override
	public void endVisit(ConditionalExpression node) {
		ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(node.resolveTypeBinding(), node);
		setConstraintVariable(node, boxed);
	}

	@Override
	public boolean visit(CatchClause node) {
		SingleVariableDeclaration exception= node.getException();
		IVariableBinding variableBinding= exception.resolveBinding();
		VariableVariable2 cv= fTCModel.makeDeclaredVariableVariable(variableBinding, fCU);
		setConstraintVariable(exception, cv);
		return true;
	}

	@Override
	public void endVisit(StringLiteral node) {
		ITypeBinding typeBinding= node.resolveTypeBinding();
		ImmutableTypeVariable2 cv= fTCModel.makeImmutableTypeVariable(typeBinding, null);
		setConstraintVariable(node, cv);
	}

	@Override
	public void endVisit(NumberLiteral node) {
		ITypeBinding typeBinding= node.resolveTypeBinding();
		ImmutableTypeVariable2 cv= fTCModel.makeImmutableTypeVariable(typeBinding, node);
		setConstraintVariable(node, cv);
	}

	@Override
	public void endVisit(BooleanLiteral node) {
		ITypeBinding typeBinding= node.resolveTypeBinding();
		ImmutableTypeVariable2 cv= fTCModel.makeImmutableTypeVariable(typeBinding, node);
		setConstraintVariable(node, cv);
	}

	@Override
	public void endVisit(CharacterLiteral node) {
		ITypeBinding typeBinding= node.resolveTypeBinding();
		ImmutableTypeVariable2 cv= fTCModel.makeImmutableTypeVariable(typeBinding, node);
		setConstraintVariable(node, cv);
	}

	@Override
	public void endVisit(ThisExpression node) {
		ITypeBinding typeBinding= node.resolveTypeBinding();
		ImmutableTypeVariable2 cv= fTCModel.makeImmutableTypeVariable(typeBinding, null);
		setConstraintVariable(node, cv);
	}

	@Override
	public void endVisit(TypeLiteral node) {
		ITypeBinding typeBinding= node.resolveTypeBinding();
		ImmutableTypeVariable2 cv= fTCModel.makeImmutableTypeVariable(typeBinding, null);
		setConstraintVariable(node, cv);
	}

	@Override
	public void endVisit(MethodDeclaration node) {
		IMethodBinding methodBinding= node.resolveBinding();
		if (methodBinding == null)
			return;
		int parameterCount= node.parameters().size();
		ConstraintVariable2[] parameterTypeCvs= new ConstraintVariable2[parameterCount];
		for (int i= 0; i < parameterCount; i++) {
			SingleVariableDeclaration paramDecl= (SingleVariableDeclaration)node.parameters().get(i);
			ConstraintVariable2 parameterTypeCv= fTCModel.makeDeclaredParameterTypeVariable(methodBinding, i, fCU);
			parameterTypeCvs[i]= parameterTypeCv;
			if (parameterTypeCv == null)
				continue;
			ConstraintVariable2 typeCv= getConstraintVariable(paramDecl.getType());
			fTCModel.createElementEqualsConstraints(parameterTypeCv, typeCv);
			ConstraintVariable2 nameCv= getConstraintVariable(paramDecl.getName());
			fTCModel.createElementEqualsConstraints(parameterTypeCv, nameCv);
		}
		ConstraintVariable2 returnTypeCv= null;
		if (!methodBinding.isConstructor()) {
			ConstraintVariable2 returnTypeBindingCv= fTCModel.makeDeclaredReturnTypeVariable(methodBinding, fCU);
			if (returnTypeBindingCv != null) {
				returnTypeCv= getConstraintVariable(node.getReturnType2());
				fTCModel.createElementEqualsConstraints(returnTypeBindingCv, returnTypeCv);
			}
		}
		if (MethodChecks.isVirtual(methodBinding)) {
			addConstraintsForOverriding(methodBinding, returnTypeCv, parameterTypeCvs);
		}
	}

	private void addConstraintsForOverriding(IMethodBinding methodBinding, ConstraintVariable2 returnTypeCv, ConstraintVariable2[] parameterTypeCvs) {
		boolean hasParameterElementCvs= false;
		for (int i= 0; i < parameterTypeCvs.length; i++)
			if (parameterTypeCvs[i] != null)
				hasParameterElementCvs= true;
		if (returnTypeCv == null && !hasParameterElementCvs)
			return;
		ITypeBinding[] allSuperTypes= Bindings.getAllSuperTypes(methodBinding.getDeclaringClass());
		for (int i= 0; i < allSuperTypes.length; i++) {
			ITypeBinding superType= allSuperTypes[i];
			IMethodBinding superMethod= Bindings.findOverriddenMethodInType(superType, methodBinding);
			if (superMethod == null)
				continue;
			for (int p= 0; p < parameterTypeCvs.length; p++) {
				if (parameterTypeCvs[p] == null)
					continue;
				ParameterTypeVariable2 parameterTypeCv= fTCModel.makeParameterTypeVariable(superMethod, p);
				fTCModel.createElementEqualsConstraints(parameterTypeCv, parameterTypeCvs[p]);
			}
			if (returnTypeCv != null) {
				ReturnTypeVariable2 superMethodReturnTypeCv= fTCModel.makeReturnTypeVariable(superMethod);
				fTCModel.createElementEqualsConstraints(superMethodReturnTypeCv, returnTypeCv);
			}
		}
	}

	@Override
	public void endVisit(MethodInvocation node) {
		IMethodBinding methodBinding= node.resolveMethodBinding();
		if (methodBinding == null)
			return;
		Expression receiver;
		if (JdtFlags.isStatic(methodBinding))
			receiver= null;
		else
			receiver= node.getExpression();
		if (isSpecialCloneInvocation(methodBinding, receiver)) {
			ConstraintVariable2 expressionCv= getConstraintVariable(receiver);
			setConstraintVariable(node, expressionCv);
		} else if ("getClass".equals(methodBinding.getName()) && methodBinding.getParameterTypes().length == 0) {
			ITypeBinding returnType= node.resolveTypeBinding();
			ITypeBinding returnTypeDeclaration= returnType.getTypeDeclaration();
			ParameterizedTypeVariable2 expressionCv= fTCModel.makeParameterizedTypeVariable(returnTypeDeclaration);
			setConstraintVariable(node, expressionCv);
			ConstraintVariable2 classTypeVariable= fTCModel.getElementVariable(expressionCv, returnTypeDeclaration.getTypeParameters()[0]);
			ITypeBinding capture= returnType.getTypeArguments()[0];
			ITypeBinding wildcard= capture.getWildcard();
			if (wildcard.getBound() == null)
				return;
			ImmutableTypeVariable2 wildcardType= fTCModel.makeImmutableTypeVariable(wildcard, null);
			fTCModel.createSubtypeConstraint(classTypeVariable, wildcardType);
		} else {
			Map methodTypeVariables= createMethodTypeArguments(methodBinding);
			doVisitMethodInvocationReturnType(node, methodBinding, receiver, methodTypeVariables);
			doVisitMethodInvocationArguments(methodBinding, node.arguments(), receiver, methodTypeVariables, null);
		}
	}

	/** 
	* @return a map from type variable key to type variable constraint variable
	*/
	private Map createMethodTypeArguments(IMethodBinding methodBinding) {
		ITypeBinding[] methodTypeParameters= methodBinding.getMethodDeclaration().getTypeParameters();
		Map methodTypeVariables;
		if (methodTypeParameters.length == 0) {
			methodTypeVariables= Collections.EMPTY_MAP;
		} else {
			methodTypeVariables= new HashMap();
			for (int i= 0; i < methodTypeParameters.length; i++) {
				ITypeBinding methodTypeParameter= methodTypeParameters[i];
				TypeVariable typeVariable= (TypeVariable)fTCModel.createTType(methodTypeParameter);
				IndependentTypeVariable2 typeVariableCv= fTCModel.makeIndependentTypeVariable(typeVariable);
				methodTypeVariables.put(methodTypeParameter.getKey(), typeVariableCv);
			}
		}
		return methodTypeVariables;
	}

	private void doVisitMethodInvocationReturnType(MethodInvocation node, IMethodBinding methodBinding, Expression receiver, Map methodTypeVariables) {
		ITypeBinding declaredReturnType= methodBinding.getMethodDeclaration().getReturnType();
		if (declaredReturnType.isPrimitive()) {
			ImmutableTypeVariable2 boxed= fTCModel.makeImmutableTypeVariable(declaredReturnType, node);
			setConstraintVariable(node, boxed);
		} else if (declaredReturnType.isTypeVariable()) {
			ConstraintVariable2 methodTypeVariableCv= (ConstraintVariable2)methodTypeVariables.get(declaredReturnType.getKey());
			if (methodTypeVariableCv != null) {
				setConstraintVariable(node, methodTypeVariableCv);
			} else {
				if (receiver == null)
					return;
				ConstraintVariable2 expressionCv= getConstraintVariable(receiver);
				ConstraintVariable2 elementCv= fTCModel.getElementVariable(expressionCv, declaredReturnType);
				setConstraintVariable(node, elementCv);
			}
		} else if (declaredReturnType.isParameterizedType()) {
			ConstraintVariable2 returnTypeCv= fTCModel.makeParameterizedTypeVariable(declaredReturnType.getTypeDeclaration());
			setConstraintVariable(node, returnTypeCv);
			ConstraintVariable2 receiverCv= null;
			if (receiver != null)
				receiverCv= getConstraintVariable(receiver);
			TType declaredReturnTType= fTCModel.createTType(declaredReturnType);
			fTCModel.createTypeVariablesEqualityConstraints(receiverCv, methodTypeVariables, returnTypeCv, declaredReturnTType);
		} else if (declaredReturnType.isArray()) {
			ConstraintVariable2 returnTypeCv= fTCModel.makeArrayTypeVariable(declaredReturnType);
			setConstraintVariable(node, returnTypeCv);
			ConstraintVariable2 receiverCv= null;
			if (receiver != null) {
				receiverCv= getConstraintVariable(receiver);
				fTCModel.setMethodReceiverCV(returnTypeCv, receiverCv);
			}
			TType declaredReturnTType= fTCModel.createTType(declaredReturnType);
			fTCModel.createTypeVariablesEqualityConstraints(receiverCv, methodTypeVariables, returnTypeCv, declaredReturnTType);
		} else {
			ReturnTypeVariable2 returnTypeCv= fTCModel.makeReturnTypeVariable(methodBinding);
			setConstraintVariable(node, returnTypeCv);
		}
	}

	private boolean isSpecialCloneInvocation(IMethodBinding methodBinding, Expression receiver) {
		return fAssumeCloneReturnsSameType && "clone".equals(methodBinding.getName()) && methodBinding.getParameterTypes().length == 0 && receiver != null
				&& receiver.resolveTypeBinding() != methodBinding.getMethodDeclaration().getReturnType();
	}

	private void doVisitMethodInvocationArguments(IMethodBinding methodBinding, List arguments, Expression receiver, Map methodTypeVariables, Type createdType) {
		ITypeBinding[] declaredParameterTypes= methodBinding.getMethodDeclaration().getParameterTypes();
		int lastParamIdx= declaredParameterTypes.length - 1;
		for (int i= 0; i < arguments.size(); i++) {
			Expression arg= (Expression)arguments.get(i);
			ConstraintVariable2 argCv= getConstraintVariable(arg);
			if (argCv == null)
				continue;
			TType declaredParameterType;
			int iParam;
			if (!methodBinding.isVarargs() || i < lastParamIdx) {
				iParam= i;
				declaredParameterType= fTCModel.createTType(declaredParameterTypes[iParam]);
			} else {
				iParam= lastParamIdx;
				declaredParameterType= fTCModel.createTType(declaredParameterTypes[iParam]);
				if (i == lastParamIdx
						&& canAssignToVararg(fTCModel.createTType(arg.resolveTypeBinding()), (org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.ArrayType)declaredParameterType)) {
				} else {
					declaredParameterType= ((org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.ArrayType)declaredParameterType).getComponentType();
				}
			}
			if (declaredParameterType.isTypeVariable()) {
				ConstraintVariable2 methodTypeVariableCv= (ConstraintVariable2)methodTypeVariables.get(declaredParameterType.getBindingKey());
				if (methodTypeVariableCv != null) {
					fTCModel.createSubtypeConstraint(argCv, methodTypeVariableCv);
				} else {
					if (createdType != null) {
						ConstraintVariable2 createdTypeCv= getConstraintVariable(createdType);
						ConstraintVariable2 elementCv= fTCModel.getElementVariable(createdTypeCv, (TypeVariable)declaredParameterType);
						fTCModel.createSubtypeConstraint(argCv, elementCv);
					}
					if (receiver != null) {
						ConstraintVariable2 expressionCv= getConstraintVariable(receiver);
						ConstraintVariable2 elementCv= fTCModel.getElementVariable(expressionCv, (TypeVariable)declaredParameterType);
						fTCModel.createSubtypeConstraint(argCv, elementCv);
					} else {
					}
				}
			} else if (declaredParameterType.isParameterizedType()) {
				TType[] typeArguments= ((ParameterizedType)declaredParameterType).getTypeArguments();
				TypeVariable[] typeParameters= ((GenericType)declaredParameterType.getTypeDeclaration()).getTypeParameters();
				for (int ta= 0; ta < typeArguments.length; ta++) {
					TType typeArgument= typeArguments[ta];
					CollectionElementVariable2 argElementCv= fTCModel.getElementVariable(argCv, typeParameters[ta]);
					if (typeArgument.isWildcardType()) {
						WildcardType wildcardTypeArgument= (WildcardType)typeArgument;
						TType bound= wildcardTypeArgument.getBound();
						if (bound != null && bound.isTypeVariable()) {
							ConstraintVariable2 methodTypeVariableCv= (ConstraintVariable2)methodTypeVariables.get(bound.getBindingKey());
							if (methodTypeVariableCv != null) {
								createWildcardConstraint(wildcardTypeArgument, argElementCv, methodTypeVariableCv);
							} else {
								if (createdType != null) {
									ConstraintVariable2 createdTypeCv= getConstraintVariable(createdType);
									CollectionElementVariable2 elementCv= fTCModel.getElementVariable(createdTypeCv, typeParameters[ta]);
									createWildcardConstraint(wildcardTypeArgument, argElementCv, elementCv);
								}
								if (receiver != null) {
									ConstraintVariable2 expressionCv= getConstraintVariable(receiver);
									CollectionElementVariable2 elementCv= fTCModel.getElementVariable(expressionCv, typeParameters[ta]);
									createWildcardConstraint(wildcardTypeArgument, argElementCv, elementCv);
								} else {
								}
							}
						} else {
						}
					} else if (typeArgument.isTypeVariable()) {
						ConstraintVariable2 methodTypeVariableCv= (ConstraintVariable2)methodTypeVariables.get(typeArgument.getBindingKey());
						if (methodTypeVariableCv != null) {
							fTCModel.createEqualsConstraint(argElementCv, methodTypeVariableCv);
						} else {
							if (createdType != null) {
								ConstraintVariable2 createdTypeCv= getConstraintVariable(createdType);
								ConstraintVariable2 elementCv= fTCModel.getElementVariable(createdTypeCv, (TypeVariable)typeArgument);
								fTCModel.createEqualsConstraint(argElementCv, elementCv);
							}
							if (receiver != null) {
								ConstraintVariable2 expressionCv= getConstraintVariable(receiver);
								ConstraintVariable2 elementCv= fTCModel.getElementVariable(expressionCv, (TypeVariable)typeArgument);
								fTCModel.createEqualsConstraint(argElementCv, elementCv);
							} else {
							}
						}
					} else {
						ImmutableTypeVariable2 typeArgumentCv= fTCModel.makeImmutableTypeVariable(typeArgument);
						fTCModel.createEqualsConstraint(argElementCv, typeArgumentCv);
					}
				}
			} else if (declaredParameterType.isArrayType()) {
				TType declaredElementType= ((org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.ArrayType)declaredParameterType).getElementType();
				if (declaredElementType.isTypeVariable()) {
					ConstraintVariable2 methodTypeVariableCv= (ConstraintVariable2)methodTypeVariables.get(declaredElementType.getBindingKey());
					if (methodTypeVariableCv != null) {
						ArrayElementVariable2 argElementCv= fTCModel.getArrayElementVariable(argCv);
						fTCModel.createEqualsConstraint(argElementCv, methodTypeVariableCv);
					} else {
					}
				} else {
				}
			} else {
				if (!InferTypeArgumentsTCModel.isAGenericType(declaredParameterType))
					continue;
				ParameterTypeVariable2 parameterTypeCv= fTCModel.makeParameterTypeVariable(methodBinding, iParam);
				fTCModel.createElementEqualsConstraints(parameterTypeCv, argCv);
			}
		}
	}

	private boolean canAssignToVararg(TType rhs, org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.ArrayType lhs) {
		return TTypes.canAssignTo(rhs.getErasure(), lhs.getErasure());
	}

	private void createWildcardConstraint(WildcardType typeArgument, CollectionElementVariable2 argElementCv, ConstraintVariable2 paramElementCv) {
		if (typeArgument.isExtendsWildcardType())
			fTCModel.createSubtypeConstraint(argElementCv, paramElementCv);
		else
			fTCModel.createSubtypeConstraint(paramElementCv, argElementCv);
	}

	@Override
	public void endVisit(ClassInstanceCreation node) {
		Expression receiver= node.getExpression();
		Type createdType= node.getType();
		ConstraintVariable2 typeCv;
		if (node.getAnonymousClassDeclaration() == null) {
			typeCv= getConstraintVariable(createdType);
		} else {
			typeCv= fTCModel.makeImmutableTypeVariable(createdType.resolveBinding(), null);
			setConstraintVariable(createdType, typeCv);
		}
		setConstraintVariable(node, typeCv);
		IMethodBinding methodBinding= node.resolveConstructorBinding();
		Map methodTypeVariables= createMethodTypeArguments(methodBinding);
		List arguments= node.arguments();
		doVisitMethodInvocationArguments(methodBinding, arguments, receiver, methodTypeVariables, createdType);
	}

	@Override
	public void endVisit(ArrayCreation node) {
		ArrayType arrayType= node.getType();
		TypeVariable2 arrayTypeCv= (TypeVariable2)getConstraintVariable(arrayType);
		if (arrayTypeCv == null)
			return;
		setConstraintVariable(node, arrayTypeCv);
	}

	@Override
	public void endVisit(ReturnStatement node) {
		Expression expression= node.getExpression();
		if (expression == null)
			return;
		ConstraintVariable2 expressionCv= getConstraintVariable(expression);
		if (expressionCv == null)
			return;
		MethodDeclaration methodDeclaration= (MethodDeclaration)ASTNodes.getParent(node, ASTNode.METHOD_DECLARATION);
		if (methodDeclaration == null)
			return;
		IMethodBinding methodBinding= methodDeclaration.resolveBinding();
		if (methodBinding == null)
			return;
		ReturnTypeVariable2 returnTypeCv= fTCModel.makeReturnTypeVariable(methodBinding);
		if (returnTypeCv == null)
			return;
		fTCModel.createElementEqualsConstraints(returnTypeCv, expressionCv);
	}

	@Override
	public void endVisit(VariableDeclarationExpression node) {
		Type type= node.getType();
		ConstraintVariable2 typeCv= getConstraintVariable(type);
		if (typeCv == null)
			return;
		setConstraintVariable(node, typeCv);
		List fragments= node.fragments();
		for (Iterator iter= fragments.iterator(); iter.hasNext();) {
			VariableDeclarationFragment fragment= (VariableDeclarationFragment)iter.next();
			ConstraintVariable2 fragmentCv= getConstraintVariable(fragment);
			fTCModel.createElementEqualsConstraints(typeCv, fragmentCv);
		}
	}

	@Override
	public void endVisit(VariableDeclarationStatement node) {
		endVisitFieldVariableDeclaration(node.getType(), node.fragments());
	}

	@Override
	public void endVisit(FieldDeclaration node) {
		endVisitFieldVariableDeclaration(node.getType(), node.fragments());
	}

	private void endVisitFieldVariableDeclaration(Type type, List variableDeclarationFragments) {
		ConstraintVariable2 typeCv= getConstraintVariable(type);
		if (typeCv == null)
			return;
		for (Iterator iter= variableDeclarationFragments.iterator(); iter.hasNext();) {
			VariableDeclarationFragment fragment= (VariableDeclarationFragment)iter.next();
			ConstraintVariable2 fragmentCv= getConstraintVariable(fragment);
			fTCModel.createElementEqualsConstraints(typeCv, fragmentCv);
		}
	}

	@Override
	public void endVisit(SingleVariableDeclaration node) {
		Expression initializer= node.getInitializer();
		if (initializer == null)
			return;
	}

	@Override
	public void endVisit(VariableDeclarationFragment node) {
		VariableVariable2 cv= fTCModel.makeDeclaredVariableVariable(node.resolveBinding(), fCU);
		if (cv == null)
			return;
		setConstraintVariable(node, cv);
		Expression initializer= node.getInitializer();
		if (initializer == null)
			return;
		ConstraintVariable2 initializerCv= getConstraintVariable(initializer);
		if (initializerCv == null)
			return;
		fTCModel.createElementEqualsConstraints(cv, initializerCv);
	}

	@Override
	public InferTypeArgumentsTCModel getTCModel() {
		return fTCModel;
	}

	/** 
	* @param node the ASTNode
	* @return the {@link ConstraintVariable2} associated with the node, or <code>null</code>
	*/
	protected static ConstraintVariable2 getConstraintVariable(ASTNode node) {
		return (ConstraintVariable2)node.getProperty(CV_PROP);
	}

	/** 
	* @param node the ASTNode
	* @param constraintVariable the {@link ConstraintVariable2} to be associated with node
	*/
	protected static void setConstraintVariable(ASTNode node, ConstraintVariable2 constraintVariable) {
		node.setProperty(CV_PROP, constraintVariable);
	}
}
