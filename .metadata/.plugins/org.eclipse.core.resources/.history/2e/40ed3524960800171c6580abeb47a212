package org.eclipse.jdt.internal.corext.refactoring.generics;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Stack;
import org.eclipse.core.runtime.Assert;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.GenericType;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TType;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.CollectionElementVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.ConstraintVariable2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.SubTypeConstraint2;
import org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.TypeEquivalenceSet;

public class ParametricStructureComputer implements IParametricStructureComputer {
	public static class ParametricStructure {
		public static final ParametricStructure NONE= new ParametricStructure();

		private final GenericType fBase;

		private final ParametricStructure[] fParameters;

		public ParametricStructure(GenericType base) {
			if (base == null)
				throw new NullPointerException();
			fBase= base;
			fParameters= new ParametricStructure[base.getTypeParameters().length];
		}

		private ParametricStructure() {
			fBase= null;
			fParameters= new ParametricStructure[0];
		}

		@Override
		public ParametricStructure[] getParameters() {
			return fParameters;
		}

		@Override
		public GenericType getBase() {
			return fBase;
		}

		@Override
		public String toString() {
			if (this == NONE)
				return "NONE";
			else
				return "ParamStructure " + fBase.toString() + '<' + Arrays.asList(fParameters) + '>';
		}
	}

	private static final boolean DEBUG_INITIALIZATION= false;

	/** 
	* Maps each ConstraintVariable2 onto an IType that is either an instance of AbstractTypeParameter, if the ConstraintVariable2 cannot possibly refer to a parametric type, or an instance of ParametricStructure with the appropriate sub-structure (if any) if it can.
	*/
	private final IElementStructureEnvironment fElemStructureEnv= new ElementStructureEnvironment();

	private final ConstraintVariable2[] fAllConstraintVariables;

	private InferTypeArgumentsTCModel fTCModel;

	public ParametricStructureComputer(ConstraintVariable2[] allConstraintVariables, InferTypeArgumentsTCModel tcModel) {
		fAllConstraintVariables= allConstraintVariables;
		fTCModel= tcModel;
	}

	@Override
	public ElementStructureEnvironment getElemStructureEnv() {
		return fElemStructureEnv;
	}

	private void dumpContainerStructure() {
		System.out.println("\n*** Container Structure: ***\n");
		for (int i= 0; i < fAllConstraintVariables.length; i++) {
			ConstraintVariable2 v= fAllConstraintVariables[i];
			if (elemStructure(v) != null && !(elemStructure(v) == ParametricStructure.NONE))
				System.out.println("elemStructure(" + v.toString() + ") = " + elemStructure(v));
		}
		System.out.println();
	}

	private Stack fWorkList2= new Stack();

	private void setStructureAndPush(ConstraintVariable2 v, ParametricStructure structure) {
		setElemStructure(v, structure);
		fWorkList2.push(v);
	}

	private void initializeContainerStructure() {
		if (DEBUG_INITIALIZATION)
			System.out.println("  *** Seeding container structure ***");
		for (int i= 0; i < fAllConstraintVariables.length; i++) {
			ConstraintVariable2 v= fAllConstraintVariables[i];
			TType varType= declaredTypeOf(v);
			if (varType != null) {
				if (isParametricType(varType) && !isUnmodifiableFieldOrMethod(v)) {
					if (DEBUG_INITIALIZATION)
						System.out.println("Entity has           container structure: " + v);
					setStructureAndPush(v, newParametricType(varType));
				} else if (!mightBeParametric(varType)) {
					if (DEBUG_INITIALIZATION)
						System.out.println("Entity DOES NOT have container structure: " + v);
					setStructureAndPush(v, ParametricStructure.NONE);
				}
			} else {
			}
		}
	}

	protected static TType declaredTypeOf(ConstraintVariable2 cv) {
		return cv.getType();
	}

	private boolean mightBeParametric(TType type) {
		return isParametricType(type);
	}

	private void computeContainerStructure() {
		if (DEBUG_INITIALIZATION)
			System.out.println("\n*** Computing Container Structure ***\n");
		initializeContainerStructure();
		if (DEBUG_INITIALIZATION)
			dumpContainerStructure();
		while (!fWorkList2.isEmpty()) {
			ConstraintVariable2 v= (ConstraintVariable2)fWorkList2.pop();
			List usedIn= fTCModel.getUsedIn(v);
			for (Iterator iter= usedIn.iterator(); iter.hasNext();) {
				SubTypeConstraint2 stc= (SubTypeConstraint2)iter.next();
				ConstraintVariable2 lhs= stc.getLeft();
				ConstraintVariable2 rhs= stc.getRight();
				unifyContainerStructure(lhs, rhs);
			}
			TypeEquivalenceSet typeEquivalenceSet= v.getTypeEquivalenceSet();
			if (typeEquivalenceSet != null) {
				ConstraintVariable2[] contributingVariables= typeEquivalenceSet.getContributingVariables();
				for (int i= 0; i + 1 < contributingVariables.length; i++) {
					ConstraintVariable2 first= contributingVariables[i];
					ConstraintVariable2 second= contributingVariables[i + 1];
					unifyContainerStructure(first, second);
				}
			}
		}
		if (DEBUG_INITIALIZATION)
			dumpContainerStructure();
	}

	private void unifyContainerStructure(ConstraintVariable2 lhs, ConstraintVariable2 rhs) {
		if (isUnmodifiableFieldOrMethod(lhs) || isUnmodifiableFieldOrMethod(rhs))
			return;
		if (DEBUG_INITIALIZATION)
			System.out.println("Examining constraint " + lhs + " {" + elemStructure(lhs) + "} <= " + rhs + " {" + elemStructure(rhs) + "}");
		if (updateStructureOfVar(lhs, elemStructure(rhs), TypeOperator.SubType)) {
			if (lhs instanceof CollectionElementVariable2)
				updateParentContainerStructureFrom((CollectionElementVariable2)lhs, rhs);
			updateElementVarStructureFromParent(lhs);
		}
		if (updateStructureOfVar(rhs, elemStructure(lhs), TypeOperator.SuperType)) {
			if (rhs instanceof CollectionElementVariable2)
				updateParentContainerStructureFrom((CollectionElementVariable2)rhs, lhs);
			updateElementVarStructureFromParent(rhs);
		}
	}

	private ParametricStructure newParametricType(TType varType) {
		GenericType genericType= (GenericType)varType.getTypeDeclaration();
		return new ParametricStructure(genericType);
	}

	private boolean isUnmodifiableFieldOrMethod(ConstraintVariable2 v) {
		return false;
	}

	private boolean isParametricType(TType type) {
		return type.isParameterizedType() || type.isGenericType() || (type.isRawType() && type.getTypeDeclaration().isGenericType());
	}

	/** 
	* Updates the structure of the i'th type parameter of the given ParametricStructure to be consistent with that of 'otherStructure'.
	*/
	private boolean updateStructureOfIthParamFrom(ParametricStructure structure1, int i, ParametricStructure otherStructure) {
		if ((otherStructure == null))
			return false;
		Assert.isTrue(structure1 != otherStructure, "updateStructureOfIthParamFrom(): attempt to unify ith param of a parametric type with itself!");
		ParametricStructure param1= structure1.getParameters()[i];
		boolean param1Unknown= (param1 == null);
		if (param1Unknown) {
			if (DEBUG_INITIALIZATION)
				System.out.println("  setting param " + i + " of " + structure1 + " to " + otherStructure);
			structure1.getParameters()[i]= otherStructure;
			return true;
		}
		boolean paramStructured= !(param1 == ParametricStructure.NONE);
		boolean otherStructured= !(otherStructure == ParametricStructure.NONE);
		if (paramStructured && otherStructured) {
			if (param1.getBase().equals(otherStructure.getBase()))
				return updateStructureOfType(param1, otherStructure);
			else {
				structure1.getParameters()[i]= ParametricStructure.NONE;
				return true;
			}
		}
		return false;
	}

	/** 
	* Updates the structure of any subsidiary element variables (if any) for the given ConstraintVariable2 (if it is in fact a container).
	*/
	private void updateElementVarStructureFromParent(ConstraintVariable2 v) {
		if (elemStructure(v) != ParametricStructure.NONE && fTCModel.getElementVariables(v).size() > 0) {
			ParametricStructure t= elemStructure(v);
			for (Iterator iterator= fTCModel.getElementVariables(v).values().iterator(); iterator.hasNext();) {
				CollectionElementVariable2 typeVar= (CollectionElementVariable2)iterator.next();
				int declarationTypeVariableIndex= typeVar.getDeclarationTypeVariableIndex();
				if (declarationTypeVariableIndex != CollectionElementVariable2.NOT_DECLARED_TYPE_VARIABLE_INDEX)
					updateStructureOfVar(typeVar, t.getParameters()[declarationTypeVariableIndex], TypeOperator.Equals);
			}
		}
	}

	/** 
	* Updates the structure of the parent container variable of the given CollectionElementVariable2 from the structure of 'v1'.
	* @param elemVar
	* @param v1
	*/
	private void updateParentContainerStructureFrom(CollectionElementVariable2 elemVar, ConstraintVariable2 v1) {
		ConstraintVariable2 elemContainer= elemVar.getParentConstraintVariable();
		ParametricStructure elemContainerStructure= elemStructure(elemContainer);
		if (elemContainerStructure == ParametricStructure.NONE)
			return;
		if (elemContainerStructure == null) {
			elemContainerStructure= newParametricType(elemContainer.getType());
			setStructureAndPush(elemContainer, elemContainerStructure);
		}
		ParametricStructure v1Structure= elemStructure(v1);
		int parmIdx= elemVar.getDeclarationTypeVariableIndex();
		if (parmIdx == CollectionElementVariable2.NOT_DECLARED_TYPE_VARIABLE_INDEX)
			return;
		if (elemContainerStructure == v1Structure || containsSubStructure(v1Structure, elemContainerStructure)) {
			if (!(elemStructure(elemVar) == ParametricStructure.NONE))
				setStructureAndPush(elemVar, ParametricStructure.NONE);
			if (elemContainerStructure.getParameters()[parmIdx] == null) {
				elemContainerStructure.getParameters()[parmIdx]= ParametricStructure.NONE;
				fWorkList2.push(elemContainer);
			}
		} else if (updateStructureOfIthParamFrom(elemContainerStructure, parmIdx, v1Structure)) {
			setStructureAndPush(elemVar, elemContainerStructure.getParameters()[parmIdx]);
			fWorkList2.push(elemContainer);
			if (DEBUG_INITIALIZATION)
				System.out.println("  updated structure of " + elemContainer + " to " + elemContainerStructure);
		}
	}

	private boolean containsSubStructure(ParametricStructure containingStructure, ParametricStructure subStructure) {
		if (containingStructure == null)
			return false;
		ParametricStructure[] parameters= containingStructure.getParameters();
		for (int i= 0; i < parameters.length; i++) {
			ParametricStructure parameter= parameters[i];
			if (parameter == subStructure)
				return true;
			else if (containsSubStructure(parameter, subStructure))
				return true;
		}
		return false;
	}

	/** 
	* Make type1's sub-structure at least as detailed as that of type2 by copying the structure of type2's parameters (or its parameters' parameters) into type1's parameters.
	*/
	private boolean updateStructureOfType(ParametricStructure type1, ParametricStructure type2) {
		if (type1 == null || type2 == null)
			return false;
		ParametricStructure[] parms1= type1.getParameters();
		ParametricStructure[] parms2= type2.getParameters();
		boolean someChange= false;
		Assert.isTrue(parms1.length == parms2.length);
		for (int i= 0; i < parms1.length; i++) {
			if (type1 == parms2[i]) {
				if (parms1[i] != ParametricStructure.NONE) {
					parms1[i]= ParametricStructure.NONE;
					someChange= true;
				}
			} else if (updateStructureOfIthParamFrom(type1, i, parms2[i]))
				someChange= true;
		}
		return someChange;
	}

	static class TypeOperator {
		private final String fOp;

		private TypeOperator(String op) {
			fOp= op;
		}

		static public TypeOperator Equals= new TypeOperator("=^=");

		static public TypeOperator SubType= new TypeOperator("<=");

		static public TypeOperator SuperType= new TypeOperator("=>");

		@Override
		public String toString() {
			return fOp;
		}
	}

	/** 
	* Updates the structure of the given ConstraintVariable to be consistent with the structure of 'type2', in accordance with the given TypeOperator. If any changes are made, pushes the variable onto fWorkList2.
	*/
	private boolean updateStructureOfVar(ConstraintVariable2 v, ParametricStructure type2, TypeOperator op) {
		if ((type2 == null))
			return false;
		ParametricStructure vStructure= elemStructure(v);
		boolean vStructureUnknown= (vStructure == null);
		boolean type2Structured= type2 != ParametricStructure.NONE;
		if (vStructureUnknown) {
			if (DEBUG_INITIALIZATION)
				System.out.println("  setting structure of " + v + " to " + type2);
			setStructureAndPush(v, type2);
			return true;
		}
		boolean vStructured= vStructure != ParametricStructure.NONE;
		if (vStructured && !type2Structured) {
			if (op == TypeOperator.Equals || op == TypeOperator.SuperType) {
				setStructureAndPush(v, type2);
				return true;
			}
		} else if (vStructured && type2Structured) {
			if (!vStructure.getBase().equals(type2.getBase())) {
				if (op == TypeOperator.SuperType) {
					setStructureAndPush(v, ParametricStructure.NONE);
					return true;
				}
			} else if (updateStructureOfType(vStructure, type2)) {
				fWorkList2.push(v);
				return true;
			}
		}
		return false;
	}

	private void setElemStructure(ConstraintVariable2 v, ParametricStructure t) {
		fElemStructureEnv.setElemStructure(v, t);
	}

	private ParametricStructure elemStructure(ConstraintVariable2 v) {
		return fElemStructureEnv.elemStructure(v);
	}

	@Override
	public Collection createElemConstraintVariables() {
		Collection newVars= new HashSet();
		computeContainerStructure();
		if (DEBUG_INITIALIZATION)
			System.out.println("\n*** Creating Element Variables: ***\n");
		for (int i= 0; i < fAllConstraintVariables.length; i++) {
			newVars.addAll(createVariablesFor(fAllConstraintVariables[i]));
		}
		return newVars;
	}

	private Collection createVariablesFor(ConstraintVariable2 v) {
		ParametricStructure t= elemStructure(v);
		if (t == null || t == ParametricStructure.NONE)
			return Collections.EMPTY_LIST;
		ParametricStructure parmType= t;
		TType base= parmType.getBase();
		if (isParametricType(base)) {
			return createAndInitVars(v, parmType);
		}
		throw new IllegalStateException("Attempt to create element variables for parametric variable of unknown type: " + parmType);
	}

	private Collection getElementVariables(GenericType base, ConstraintVariable2 parent) {
		fTCModel.makeElementVariables(parent, base);
		return fTCModel.getElementVariables(parent).values();
	}

	private Collection createAndInitVars(ConstraintVariable2 v, ParametricStructure parmType) {
		Collection elementVars= getElementVariables(parmType.getBase(), v);
		Collection result= createVars(elementVars, parmType.getParameters());
		return result;
	}

	private Collection createVars(Collection cvs, ParametricStructure[] parms) {
		if (parms.length > 0) {
			for (Iterator iter= cvs.iterator(); iter.hasNext();) {
				CollectionElementVariable2 childVar= (CollectionElementVariable2)iter.next();
				int declarationTypeVariableIndex= childVar.getDeclarationTypeVariableIndex();
				if (declarationTypeVariableIndex != CollectionElementVariable2.NOT_DECLARED_TYPE_VARIABLE_INDEX)
					setElemStructure(childVar, parms[declarationTypeVariableIndex]);
			}
		} else {
			for (Iterator iter= cvs.iterator(); iter.hasNext();) {
				CollectionElementVariable2 childVar= (CollectionElementVariable2)iter.next();
				int declarationTypeVariableIndex= childVar.getDeclarationTypeVariableIndex();
				if (declarationTypeVariableIndex != CollectionElementVariable2.NOT_DECLARED_TYPE_VARIABLE_INDEX)
					setElemStructure(childVar, ParametricStructure.NONE);
			}
		}
		List result= new ArrayList(cvs.size() * 2);
		for (Iterator iter= cvs.iterator(); iter.hasNext();) {
			CollectionElementVariable2 childVar= (CollectionElementVariable2)iter.next();
			int declarationTypeVariableIndex= childVar.getDeclarationTypeVariableIndex();
			if (declarationTypeVariableIndex != CollectionElementVariable2.NOT_DECLARED_TYPE_VARIABLE_INDEX) {
				result.add(childVar);
				result.addAll(createVariablesFor(childVar));
			}
		}
		return result;
	}
}
