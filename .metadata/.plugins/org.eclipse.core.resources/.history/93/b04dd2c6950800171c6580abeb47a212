package org.eclipse.jdt.internal.corext.refactoring.rename;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.core.runtime.SubProgressMonitor;
import org.eclipse.jdt.core.IMember;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IRegion;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.ITypeHierarchy;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.WorkingCopyOwner;
import org.eclipse.jdt.core.search.IJavaSearchConstants;
import org.eclipse.jdt.core.search.IJavaSearchScope;
import org.eclipse.jdt.core.search.SearchEngine;
import org.eclipse.jdt.core.search.SearchMatch;
import org.eclipse.jdt.core.search.SearchParticipant;
import org.eclipse.jdt.core.search.SearchPattern;
import org.eclipse.jdt.core.search.SearchRequestor;
import org.eclipse.jdt.internal.corext.refactoring.RefactoringScopeFactory;
import org.eclipse.jdt.internal.corext.refactoring.base.ReferencesInBinaryContext;
import org.eclipse.jdt.internal.corext.util.JavaModelUtil;
import org.eclipse.jdt.internal.corext.util.SearchUtils;

public class RippleMethodFinder2 implements IRippleMethodFinder2 {
	private final IMethod fMethod;

	private List fDeclarations;

	private ITypeHierarchy fHierarchy;

	private Map fTypeToMethod;

	private Set fRootTypes;

	private MultiMap fRootReps;

	private Map fRootHierarchies;

	private UnionFind fUnionFind;

	private final boolean fExcludeBinaries;

	private final IReferencesInBinaryContext fBinaryRefs;

	private Map fDeclarationToMatch;

	private static class MultiMap {
		HashMap fImplementation= new HashMap();

		@Override
		public void put(IType key, IType value) {
			Collection collection= (Collection)fImplementation.get(key);
			if (collection == null) {
				collection= new HashSet();
				fImplementation.put(key, collection);
			}
			collection.add(value);
		}

		@Override
		public Collection get(IType key) {
			return (Collection)fImplementation.get(key);
		}
	}

	private static class UnionFind {
		HashMap fElementToRepresentative= new HashMap();

		@Override
		public void init(IType type) {
			fElementToRepresentative.put(type, type);
		}

		@Override
		public IType find(IType element) {
			IType root= element;
			IType rep= (IType)fElementToRepresentative.get(root);
			while (rep != null && !rep.equals(root)) {
				root= rep;
				rep= (IType)fElementToRepresentative.get(root);
			}
			if (rep == null)
				return null;
			rep= (IType)fElementToRepresentative.get(element);
			while (!rep.equals(root)) {
				IType temp= element;
				element= rep;
				fElementToRepresentative.put(temp, root);
				rep= (IType)fElementToRepresentative.get(element);
			}
			return root;
		}

		@Override
		public void union(IType rep1, IType rep2) {
			fElementToRepresentative.put(rep1, rep2);
		}
	}

	private RippleMethodFinder2(IMethod method, boolean excludeBinaries) {
		fMethod= method;
		fExcludeBinaries= excludeBinaries;
		fBinaryRefs= null;
	}

	private RippleMethodFinder2(IMethod method, ReferencesInBinaryContext binaryRefs) {
		fMethod= method;
		fExcludeBinaries= true;
		fDeclarationToMatch= new HashMap();
		fBinaryRefs= binaryRefs;
	}

	public static IMethod[] getRelatedMethods(IMethod method, boolean excludeBinaries, IProgressMonitor pm, WorkingCopyOwner owner) throws CoreException {
		try {
			if (!MethodChecks.isVirtual(method))
				return new IMethod[] { method };
			return new RippleMethodFinder2(method, excludeBinaries).getAllRippleMethods(pm, owner);
		} finally {
			pm.done();
		}
	}

	public static IMethod[] getRelatedMethods(IMethod method, IProgressMonitor pm, WorkingCopyOwner owner) throws CoreException {
		return getRelatedMethods(method, true, pm, owner);
	}

	public static IMethod[] getRelatedMethods(IMethod method, ReferencesInBinaryContext binaryRefs, IProgressMonitor pm, WorkingCopyOwner owner) throws CoreException {
		try {
			if (!MethodChecks.isVirtual(method))
				return new IMethod[] { method };
			return new RippleMethodFinder2(method, binaryRefs).getAllRippleMethods(pm, owner);
		} finally {
			pm.done();
		}
	}

	private IMethod[] getAllRippleMethods(IProgressMonitor pm, WorkingCopyOwner owner) throws CoreException {
		IMethod[] rippleMethods= findAllRippleMethods(pm, owner);
		if (fDeclarationToMatch == null)
			return rippleMethods;
		List rippleMethodsList= new ArrayList(Arrays.asList(rippleMethods));
		for (Iterator iter= rippleMethodsList.iterator(); iter.hasNext();) {
			Object match= fDeclarationToMatch.get(iter.next());
			if (match != null) {
				iter.remove();
				fBinaryRefs.add((SearchMatch)match);
			}
		}
		fDeclarationToMatch= null;
		return (IMethod[])rippleMethodsList.toArray(new IMethod[rippleMethodsList.size()]);
	}

	private IMethod[] findAllRippleMethods(IProgressMonitor pm, WorkingCopyOwner owner) throws CoreException {
		pm.beginTask("", 4);
		findAllDeclarations(new SubProgressMonitor(pm, 1), owner);
		if (!fDeclarations.contains(fMethod))
			Assert.isTrue(false, "Search for method declaration did not find original element: " + fMethod.toString());
		createHierarchyOfDeclarations(new SubProgressMonitor(pm, 1), owner);
		createTypeToMethod();
		createUnionFind();
		if (pm.isCanceled())
			throw new OperationCanceledException();
		fHierarchy= null;
		fRootTypes= null;
		Map partitioning= new HashMap();
		for (Iterator iter= fTypeToMethod.keySet().iterator(); iter.hasNext();) {
			IType type= (IType)iter.next();
			IType rep= fUnionFind.find(type);
			List types= (List)partitioning.get(rep);
			if (types == null)
				types= new ArrayList();
			types.add(type);
			partitioning.put(rep, types);
		}
		Assert.isTrue(partitioning.size() > 0);
		if (partitioning.size() == 1)
			return (IMethod[])fDeclarations.toArray(new IMethod[fDeclarations.size()]);
		IType methodTypeRep= fUnionFind.find(fMethod.getDeclaringType());
		List relatedTypes= (List)partitioning.get(methodTypeRep);
		boolean hasRelatedInterfaces= false;
		List relatedMethods= new ArrayList();
		for (Iterator iter= relatedTypes.iterator(); iter.hasNext();) {
			IType relatedType= (IType)iter.next();
			relatedMethods.add(fTypeToMethod.get(relatedType));
			if (relatedType.isInterface())
				hasRelatedInterfaces= true;
		}
		List alienDeclarations= new ArrayList(fDeclarations);
		fDeclarations= null;
		alienDeclarations.removeAll(relatedMethods);
		List alienTypes= new ArrayList();
		boolean hasAlienInterfaces= false;
		for (Iterator iter= alienDeclarations.iterator(); iter.hasNext();) {
			IMethod alienDeclaration= (IMethod)iter.next();
			IType alienType= alienDeclaration.getDeclaringType();
			alienTypes.add(alienType);
			if (alienType.isInterface())
				hasAlienInterfaces= true;
		}
		if (alienTypes.size() == 0)
			return (IMethod[])relatedMethods.toArray(new IMethod[relatedMethods.size()]);
		if (!hasRelatedInterfaces && !hasAlienInterfaces)
			return (IMethod[])relatedMethods.toArray(new IMethod[relatedMethods.size()]);
		HashSet relatedSubTypes= new HashSet();
		List relatedTypesToProcess= new ArrayList(relatedTypes);
		while (relatedTypesToProcess.size() > 0) {
			for (Iterator iter= relatedTypesToProcess.iterator(); iter.hasNext();) {
				if (pm.isCanceled())
					throw new OperationCanceledException();
				IType relatedType= (IType)iter.next();
				ITypeHierarchy hierarchy= getCachedHierarchy(relatedType, owner, new SubProgressMonitor(pm, 1));
				if (hierarchy == null)
					hierarchy= relatedType.newTypeHierarchy(owner, new SubProgressMonitor(pm, 1));
				IType[] allSubTypes= hierarchy.getAllSubtypes(relatedType);
				for (int i= 0; i < allSubTypes.length; i++)
					relatedSubTypes.add(allSubTypes[i]);
			}
			relatedTypesToProcess.clear();
			HashSet marriedAlienTypeReps= new HashSet();
			for (Iterator iter= alienTypes.iterator(); iter.hasNext();) {
				if (pm.isCanceled())
					throw new OperationCanceledException();
				IType alienType= (IType)iter.next();
				IMethod alienMethod= (IMethod)fTypeToMethod.get(alienType);
				ITypeHierarchy hierarchy= getCachedHierarchy(alienType, owner, new SubProgressMonitor(pm, 1));
				if (hierarchy == null)
					hierarchy= alienType.newTypeHierarchy(owner, new SubProgressMonitor(pm, 1));
				IType[] allSubtypes= hierarchy.getAllSubtypes(alienType);
				for (int i= 0; i < allSubtypes.length; i++) {
					IType subtype= allSubtypes[i];
					if (relatedSubTypes.contains(subtype)) {
						if (JavaModelUtil.isVisibleInHierarchy(alienMethod, subtype.getPackageFragment())) {
							marriedAlienTypeReps.add(fUnionFind.find(alienType));
						} else {
						}
					}
				}
			}
			if (marriedAlienTypeReps.size() == 0)
				return (IMethod[])relatedMethods.toArray(new IMethod[relatedMethods.size()]);
			for (Iterator iter= marriedAlienTypeReps.iterator(); iter.hasNext();) {
				IType marriedAlienTypeRep= (IType)iter.next();
				List marriedAlienTypes= (List)partitioning.get(marriedAlienTypeRep);
				for (Iterator iterator= marriedAlienTypes.iterator(); iterator.hasNext();) {
					IType marriedAlienInterfaceType= (IType)iterator.next();
					relatedMethods.add(fTypeToMethod.get(marriedAlienInterfaceType));
				}
				alienTypes.removeAll(marriedAlienTypes);
				relatedTypesToProcess.addAll(marriedAlienTypes);
			}
		}
		fRootReps= null;
		fRootHierarchies= null;
		fTypeToMethod= null;
		fUnionFind= null;
		return (IMethod[])relatedMethods.toArray(new IMethod[relatedMethods.size()]);
	}

	private ITypeHierarchy getCachedHierarchy(IType type, WorkingCopyOwner owner, IProgressMonitor monitor) throws JavaModelException {
		IType rep= fUnionFind.find(type);
		if (rep != null) {
			Collection collection= fRootReps.get(rep);
			for (Iterator iter= collection.iterator(); iter.hasNext();) {
				IType root= (IType)iter.next();
				ITypeHierarchy hierarchy= (ITypeHierarchy)fRootHierarchies.get(root);
				if (hierarchy == null) {
					hierarchy= root.newTypeHierarchy(owner, new SubProgressMonitor(monitor, 1));
					fRootHierarchies.put(root, hierarchy);
				}
				if (hierarchy.contains(type))
					return hierarchy;
			}
		}
		return null;
	}

	private void findAllDeclarations(IProgressMonitor monitor, WorkingCopyOwner owner) throws CoreException {
		fDeclarations= new ArrayList();
		class MethodRequestor extends SearchRequestor {
			public void acceptSearchMatch(SearchMatch match) throws CoreException {
				IMethod method= (IMethod)match.getElement();
				boolean isBinary= method.isBinary();
				if (fBinaryRefs != null || !(fExcludeBinaries && isBinary)) {
					fDeclarations.add(method);
				}
				if (isBinary && fBinaryRefs != null) {
					fDeclarationToMatch.put(method, match);
				}
			}
		}
		int limitTo= IJavaSearchConstants.DECLARATIONS | IJavaSearchConstants.IGNORE_DECLARING_TYPE | IJavaSearchConstants.IGNORE_RETURN_TYPE;
		int matchRule= SearchPattern.R_ERASURE_MATCH | SearchPattern.R_CASE_SENSITIVE;
		SearchPattern pattern= SearchPattern.createPattern(fMethod, limitTo, matchRule);
		SearchParticipant[] participants= SearchUtils.getDefaultSearchParticipants();
		IJavaSearchScope scope= RefactoringScopeFactory.createRelatedProjectsScope(fMethod.getJavaProject(),
				IJavaSearchScope.SOURCES | IJavaSearchScope.APPLICATION_LIBRARIES | IJavaSearchScope.SYSTEM_LIBRARIES);
		MethodRequestor requestor= new MethodRequestor();
		SearchEngine searchEngine= owner != null ? new SearchEngine(owner) : new SearchEngine();
		searchEngine.search(pattern, participants, scope, requestor, monitor);
	}

	private void createHierarchyOfDeclarations(IProgressMonitor pm, WorkingCopyOwner owner) throws JavaModelException {
		IRegion region= JavaCore.newRegion();
		for (Iterator iter= fDeclarations.iterator(); iter.hasNext();) {
			IType declaringType= ((IMethod)iter.next()).getDeclaringType();
			region.add(declaringType);
		}
		fHierarchy= JavaCore.newTypeHierarchy(region, owner, pm);
	}

	private void createTypeToMethod() {
		fTypeToMethod= new HashMap();
		for (Iterator iter= fDeclarations.iterator(); iter.hasNext();) {
			IMethod declaration= (IMethod)iter.next();
			fTypeToMethod.put(declaration.getDeclaringType(), declaration);
		}
	}

	private void createUnionFind() throws JavaModelException {
		fRootTypes= new HashSet(fTypeToMethod.keySet());
		fUnionFind= new UnionFind();
		for (Iterator iter= fTypeToMethod.keySet().iterator(); iter.hasNext();) {
			IType type= (IType)iter.next();
			fUnionFind.init(type);
		}
		for (Iterator iter= fTypeToMethod.keySet().iterator(); iter.hasNext();) {
			IType type= (IType)iter.next();
			uniteWithSupertypes(type, type);
		}
		fRootReps= new MultiMap();
		for (Iterator iter= fRootTypes.iterator(); iter.hasNext();) {
			IType type= (IType)iter.next();
			IType rep= fUnionFind.find(type);
			if (rep != null)
				fRootReps.put(rep, type);
		}
		fRootHierarchies= new HashMap();
	}

	private void uniteWithSupertypes(IType anchor, IType type) throws JavaModelException {
		IType[] supertypes= fHierarchy.getSupertypes(type);
		for (int i= 0; i < supertypes.length; i++) {
			IType supertype= supertypes[i];
			IType superRep= fUnionFind.find(supertype);
			if (superRep == null) {
				uniteWithSupertypes(anchor, supertype);
			} else {
				IMember superMethod= (IMember)fTypeToMethod.get(supertype);
				if (JavaModelUtil.isVisibleInHierarchy(superMethod, anchor.getPackageFragment())) {
					IType rep= fUnionFind.find(anchor);
					fUnionFind.union(rep, superRep);
					fRootTypes.remove(anchor);
					uniteWithSupertypes(supertype, supertype);
				} else {
				}
			}
		}
	}
}
