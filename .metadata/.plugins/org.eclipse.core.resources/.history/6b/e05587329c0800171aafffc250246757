package com.successfactors.cdp.service.mentoring.jam.util;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.UnsupportedCharsetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpEntityEnclosingRequestBase;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPatch;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpPut;
import org.apache.http.client.methods.HttpRequestBase;
import org.apache.http.conn.params.ConnManagerParams;
import org.apache.http.conn.params.ConnPerRouteBean;
import org.apache.http.conn.params.ConnRoutePNames;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.entity.StringEntity;
import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.CoreConnectionPNames;
import org.apache.http.params.HttpParams;
import org.apache.http.util.EntityUtils;

import com.sf.sfv4.util.StringUtils;
import com.successfactors.logging.api.LogManager;
import com.successfactors.logging.api.Logger;


/**
 * Http Client Util
 * 
 * @author rsrigiri
 * 
 * SAP SuccessFactors
*/
public class HttpClientUtil {

  /** log. */
  private static Logger logger = LogManager.getLogger();

  /** HTTP time out in ms */
  private static final int HTTP_TIMEOUT = 20000;

  /** Max http connections */
  private static final int MAX_TOTAL_CONNECTIONS = 100;

  /** Http port number */
  private static final int HTTP_PORT = 80;

  /** Https port number */
  private static final int HTTPS_PORT = 443;

  /** Http */
  private static final String HTTP = "http";  

  /** Https */
  private static final String HTTPS = "https";

  /** default http proxy port */
  private static final int DEFAULT_HTTP_PROXY_PORT = 8080;

  /** default https proxy port */
  private static final int DEFAULT_HTTPS_PROXY_PORT = 443;

  /** http client instances */
  private static final HttpClient HTTP_CLIENT;
  private static final HttpClient HTTPS_CLIENT;

  static {
    HttpParams paramsHttp = new BasicHttpParams();
    paramsHttp.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, HTTP_TIMEOUT);
    paramsHttp.setParameter(CoreConnectionPNames.SO_TIMEOUT, HTTP_TIMEOUT);

    ConnManagerParams.setMaxTotalConnections(paramsHttp, MAX_TOTAL_CONNECTIONS);
    // the max number of route connections is the same as the max total
    ConnManagerParams.setMaxConnectionsPerRoute(paramsHttp,
            new ConnPerRouteBean(ConnManagerParams.getMaxTotalConnections(paramsHttp)));

    SchemeRegistry schemeRegistryhttp = new SchemeRegistry();
    schemeRegistryhttp.register(new Scheme(HTTP, PlainSocketFactory
            .getSocketFactory(), HTTP_PORT));
    schemeRegistryhttp.register(new Scheme(HTTPS, SSLSocketFactory
            .getSystemSocketFactory(), HTTPS_PORT));
    ThreadSafeClientConnManager cmHttp = new ThreadSafeClientConnManager(paramsHttp,
            schemeRegistryhttp);
    HTTP_CLIENT = getHTTPProxyClient(paramsHttp, cmHttp);

    HttpParams paramsHttps = new BasicHttpParams();
    paramsHttps.setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, HTTP_TIMEOUT);
    paramsHttps.setParameter(CoreConnectionPNames.SO_TIMEOUT, HTTP_TIMEOUT);

    ConnManagerParams.setMaxTotalConnections(paramsHttps, MAX_TOTAL_CONNECTIONS);
    // the max number of route connections is the same as the max total
    ConnManagerParams.setMaxConnectionsPerRoute(paramsHttps,
            new ConnPerRouteBean(ConnManagerParams.getMaxTotalConnections(paramsHttps)));

    SchemeRegistry schemeRegistryHttps = new SchemeRegistry();
    //https also need http to be registered
    schemeRegistryHttps.register(new Scheme(HTTP, PlainSocketFactory
            .getSocketFactory(), HTTP_PORT));
    schemeRegistryHttps.register(new Scheme(HTTPS, SSLSocketFactory
            .getSystemSocketFactory(), HTTPS_PORT));
    ThreadSafeClientConnManager cmHttps = new ThreadSafeClientConnManager(paramsHttps,
            schemeRegistryHttps);
    HTTPS_CLIENT = getHTTPSProxyClient(paramsHttps, cmHttps);
  }

  private HttpClientUtil() {
  }

  private static HttpClient getHttpClient(String url) {
    try {
      URL aURL = new URL(url);

      if (aURL.getProtocol().equals(HTTP)) {
        return HTTP_CLIENT;
      } else {
        return HTTPS_CLIENT;
      }
    } catch (MalformedURLException e) {
      logger.error("Failed to parse URL: "+url, e);
      return null;
    }
  }


  private static HttpClient getHTTPProxyClient(HttpParams params, ThreadSafeClientConnManager cm) {
    HttpHost proxy = null;
    String proxyHost = System.getProperty("http.proxyHost");
    if (!StringUtils.isBlank(proxyHost)) {
      int proxyPort = Integer.getInteger("http.proxyPort", DEFAULT_HTTP_PROXY_PORT);
      proxy = new HttpHost(proxyHost, proxyPort, "http");
      logger.info("HTTP proxy detected: proxyHost="+proxyHost+", proxyPort=" + proxyPort);
    }

    if (null != proxy) {
      params.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
    }

    return new DefaultHttpClient(cm, params);
  }

  private static HttpClient getHTTPSProxyClient(HttpParams params, ThreadSafeClientConnManager cm) {
    HttpHost proxy = null;
    String proxyHost = System.getProperty("https.proxyHost");
    if (!StringUtils.isBlank(proxyHost)) {
      int proxyPort = Integer.getInteger("https.proxyPort", DEFAULT_HTTPS_PROXY_PORT);
      proxy = new HttpHost(proxyHost, proxyPort, "http");
      logger.info("HTTPS proxy detected: proxyHost="+proxyHost+", proxyPort=" + proxyPort);
    }

    if (null != proxy) {
      params.setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);
    }

    return new DefaultHttpClient(cm, params);
  }

  /**
   * Process URL
   * 
   * @param url   url
   * @param method   method
   * @param requestHeaders  headers
   * 
   * @return BasicHttpResponse response
   */
  public static BasicHttpResponse processUrl(String url, 
      String method, List<? extends NameValuePair> requestHeaders) {
    return processUrl(url, method,requestHeaders, null);
  }

  /**
   * Process URL with String requestBody
   * 
   * @param url   url to call
   * @param methodName  methodName of call GET/PUT/DELETE/POST
   * @param requestHeaders request headers
   * @param requestBody    request body
   * 
   * @return  BasicHttpResponse response
   */
  public static BasicHttpResponse processUrl(String url, String methodName,
              List<? extends NameValuePair> requestHeaders, String requestBody) {

    HttpClient httpClient = getHttpClient(url);

    HttpRequestBase method = null;

    if (HttpGet.METHOD_NAME.equals(methodName)) {
      method = new HttpGet(url);
    } else if (HttpDelete.METHOD_NAME.equals(methodName)) {
      method = new HttpDelete(url);
    } else if (HttpPost.METHOD_NAME.equals(methodName)) {
      HttpPost pp = new HttpPost(url);
      populateRequestEntity(requestBody, pp);
      method = pp;
    } else if (HttpPatch.METHOD_NAME.equals(methodName)) {
      HttpPatch pp = new HttpPatch(url);
      populateRequestEntity(requestBody, pp);
      method = pp;
    } else if (HttpPut.METHOD_NAME.equals(methodName)) {
      HttpPut pp = new HttpPut(url);
      populateRequestEntity(requestBody, pp);
      method = pp;
    }

      setRequestHeaders(method, requestHeaders);

      HttpEntity responseEntity = null;

      try {
        logger.info("Invoking URL:"+url+" ; "+ "Request Type:"+methodName);

        HttpResponse response = httpClient.execute(method);

        responseEntity = response.getEntity();

        return getBasicHttpResponse(response);
      } catch(IOException e) {
        logger.error("Exception occured while access url:" + url, e);
        throw new RuntimeException(e);
      }
      finally {
      releaseConnection(responseEntity);
    }
  }

  /**
   * Process URL with a MultipartEntity
   * 
   * @param url   url to call
   * @param methodName  methodName of call GET/PUT/POST
   * @param requestHeaders request headers
   * @param mpe   multipart entity
   * 
   * @return  BasicHttpResponse response
   * 
   * @throws IOException if error
   */
  public static BasicHttpResponse processUrlWithMPE(String url, String methodName,
      List<? extends NameValuePair> requestHeaders, MultipartEntity mpe) {

    HttpClient httpClient = getHttpClient(url);

    HttpRequestBase method = null;
    
    if (HttpGet.METHOD_NAME.equals(methodName)) {
      method = new HttpGet(url);
    } else if (HttpDelete.METHOD_NAME.equals(methodName)) {
      method = new HttpDelete(url);
    } else if (HttpPost.METHOD_NAME.equals(methodName)) {
      HttpPost pp = new HttpPost(url);

      if (mpe != null) {
        pp.setEntity(mpe);
      }

      method = pp;
    } else if (HttpPatch.METHOD_NAME.equals(methodName)) {
      HttpPatch pp = new HttpPatch(url);

      if (mpe != null) {
        pp.setEntity(mpe);
      }

      method = pp;
    } else if (HttpPut.METHOD_NAME.equals(methodName)) {
      HttpPut pp = new HttpPut(url);

      if (mpe != null) {
        pp.setEntity(mpe);
      }

      method = pp;
    }

    setRequestHeaders(method, requestHeaders);

    HttpEntity responseEntity = null;

    try {
      logger.info("Invoking MultipartRequest URL:"+url+"; "+ "Request Type:"+methodName);

      HttpResponse response = httpClient.execute(method);

      responseEntity = response.getEntity();

      return getBasicHttpResponse(response);
    } catch(IOException e) {
      logger.error("Exception occured while access multipart request url:" + url, e);
      throw new RuntimeException(e);
    }
    finally {
      releaseConnection(responseEntity);
    }
  }

  private static BasicHttpResponse getBasicHttpResponse(HttpResponse response) 
      throws IOException {
    String output = "";

    HttpEntity responseEntity = response.getEntity();

    if (responseEntity != null) {
      output = EntityUtils.toString(responseEntity);
    }

    Map<String, String> headersMap = getHeadersMap(response);

    int statusCode = response.getStatusLine().getStatusCode();

    logger.info("Response Status:"+statusCode);

    return new BasicHttpResponse(statusCode, headersMap, output);
  }

  private static Map<String, String> getHeadersMap(HttpResponse response) {
    Header[] allHeaders = response.getAllHeaders();
    Map<String, String> headersMap = new HashMap<String, String>();
    for (Header header : allHeaders) {
      headersMap.put(header.getName(), header.getValue());
    }

    return headersMap;
  }

  private static void setRequestHeaders(HttpRequestBase method, 
                        List<? extends NameValuePair> requestHeaders) {
    if (requestHeaders != null) {
      for (NameValuePair requestHeader : requestHeaders) {
        method.addHeader(requestHeader.getName(), requestHeader.getValue());
      }
    }
  }

  private static void populateRequestEntity(String requestBody, 
      HttpEntityEnclosingRequestBase pp) {

    if (requestBody != null) {
      StringEntity payload = createRequestEntity(requestBody);
      pp.setEntity(payload);
    }
  }

  private static StringEntity createRequestEntity(String requestBody)  {
    try {
      return new StringEntity(requestBody, "UTF-8");
    } catch (UnsupportedCharsetException e) {
      throw new RuntimeException(e);
    }
  }

  private static void releaseConnection(HttpEntity responseEntity) {
    if (null != responseEntity) {
      try {
        responseEntity.consumeContent();
      } catch (IOException e) {
        logger.error("Error during resource release after the response handling", e);
        throw new RuntimeException(e);
      }
    }
  }
}