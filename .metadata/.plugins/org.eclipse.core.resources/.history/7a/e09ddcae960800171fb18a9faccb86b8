package org.eclipse.jdt.internal.ui.refactoring.nls.search;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.filebuffers.FileBuffers;
import org.eclipse.core.filebuffers.ITextFileBuffer;
import org.eclipse.core.filebuffers.ITextFileBufferManager;
import org.eclipse.core.filebuffers.LocationKind;
import org.eclipse.jface.text.Position;
import org.eclipse.search.ui.text.Match;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IField;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.ISourceReference;
import org.eclipse.jdt.core.ToolFactory;
import org.eclipse.jdt.core.compiler.IScanner;
import org.eclipse.jdt.core.compiler.ITerminalSymbols;
import org.eclipse.jdt.core.compiler.InvalidInputException;
import org.eclipse.jdt.core.search.SearchMatch;
import org.eclipse.jdt.core.search.SearchRequestor;
import org.eclipse.jdt.internal.corext.refactoring.nls.PropertyFileDocumentModel;
import org.eclipse.jdt.internal.corext.util.JavaModelUtil;
import org.eclipse.jdt.internal.ui.JavaPlugin;
import org.eclipse.jdt.internal.ui.util.StringMatcher;
import org.eclipse.jdt.internal.ui.util.IStringMatcher;

class NLSSearchResultRequestor extends SearchRequestor implements INLSSearchResultRequestor {
	private static final IStringMatcher fgGetClassNameMatcher= new StringMatcher("*.class.getName()*", false, false);

	private NLSSearchResult fResult;

	private IFile fPropertiesFile;

	private Properties fProperties;

	private HashSet fUsedPropertyNames;

	public NLSSearchResultRequestor(IFile propertiesFile, NLSSearchResult result) {
		fPropertiesFile= propertiesFile;
		fResult= result;
	}

	@Override
	public void beginReporting() {
		loadProperties();
		fUsedPropertyNames= new HashSet(fProperties.size());
	}

	@Override
	public void acceptSearchMatch(SearchMatch match) throws CoreException {
		if (match.getAccuracy() == SearchMatch.A_INACCURATE)
			return;
		int offset= match.getOffset();
		int length= match.getLength();
		if (offset == -1 || length == -1)
			return;
		if (!(match.getElement() instanceof IJavaElement))
			return;
		IJavaElement javaElement= (IJavaElement)match.getElement();
		if (javaElement.getElementType() == IJavaElement.IMPORT_DECLARATION)
			return;
		if (javaElement.getElementType() == IJavaElement.CLASS_FILE)
			return;
		if (javaElement.getElementType() == IJavaElement.TYPE)
			return;
		if (javaElement.getElementType() == IJavaElement.FIELD) {
			IField field= (IField)javaElement;
			String source= field.getSource();
			if (source != null && fgGetClassNameMatcher.match(source))
				return;
		}
		if (javaElement instanceof ISourceReference) {
			String source= ((ISourceReference)javaElement).getSource();
			if (source != null) {
				if (source.indexOf("NLS.initializeMessages") != -1)
					return;
			}
		}
		Position mutableKeyPosition= new Position(offset, length);
		String key= findKey(mutableKeyPosition, javaElement);
		if (key != null && isKeyDefined(key))
			return;
		ICompilationUnit[] allCompilationUnits= JavaModelUtil.getAllCompilationUnits(new IJavaElement[] { javaElement });
		Object element= javaElement;
		if (allCompilationUnits != null && allCompilationUnits.length == 1)
			element= allCompilationUnits[0];
		fResult.addMatch(new Match(element, mutableKeyPosition.getOffset(), mutableKeyPosition.getLength()));
	}

	@Override
	public void reportUnusedPropertyNames(IProgressMonitor pm) {
		pm.beginTask("", fProperties.size());
		boolean hasUnused= false;
		pm.setTaskName(NLSSearchMessages.NLSSearchResultRequestor_searching);
		FileEntry groupElement= new FileEntry(fPropertiesFile, NLSSearchMessages.NLSSearchResultCollector_unusedKeys);
		for (Enumeration enumeration= fProperties.propertyNames(); enumeration.hasMoreElements();) {
			String propertyName= (String)enumeration.nextElement();
			if (!fUsedPropertyNames.contains(propertyName)) {
				addMatch(groupElement, propertyName);
				hasUnused= true;
			}
			pm.worked(1);
		}
		if (hasUnused)
			fResult.addFileEntryGroup(groupElement);
		pm.done();
	}

	private void addMatch(FileEntry groupElement, String propertyName) {
		String escapedPropertyName= PropertyFileDocumentModel.unwindEscapeChars(propertyName);
		int start= findPropertyNameStartPosition(escapedPropertyName);
		int length;
		if (start == -1) {
			start= 0;
			length= 0;
		} else {
			length= escapedPropertyName.length();
		}
		fResult.addMatch(new Match(groupElement, start, length));
	}

	/** 
	* Checks if the key is defined in the property file and adds it to the list of used properties.
	* @param key the key
	* @return <code>true</code> if the key is defined
	*/
	private boolean isKeyDefined(String key) {
		if (key == null)
			return true;
		fUsedPropertyNames.add(key);
		if (fProperties.getProperty(key) != null) {
			return true;
		}
		return false;
	}

	@Override
	public boolean hasPropertyKey(String key) {
		return fProperties.containsKey(key);
	}

	@Override
	public boolean isUsedPropertyKey(String key) {
		return fUsedPropertyNames.contains(key);
	}

	/** 
	* Finds the key defined by the given match. The assumption is that the key is the first argument and it is a string i.e. quoted ("...").
	* @param keyPositionResult reference parameter: will be filled with the position of the found key
	* @param enclosingElement enclosing java element
	* @return a string denoting the key, null if no key can be found
	* @throws CoreException if a problem occurs while accessing the <code>enclosingElement</code>
	*/
	private String findKey(Position keyPositionResult, IJavaElement enclosingElement) throws CoreException {
		ICompilationUnit unit= (ICompilationUnit)enclosingElement.getAncestor(IJavaElement.COMPILATION_UNIT);
		if (unit == null)
			return null;
		String source= unit.getSource();
		if (source == null)
			return null;
		IScanner scanner= ToolFactory.createScanner(false, false, false, false);
		scanner.setSource(source.toCharArray());
		scanner.resetTo(keyPositionResult.getOffset() + keyPositionResult.getLength(), source.length());
		try {
			if (scanner.getNextToken() != ITerminalSymbols.TokenNameDOT)
				return null;
			if (scanner.getNextToken() != ITerminalSymbols.TokenNameIdentifier)
				return null;
			String src= new String(scanner.getCurrentTokenSource());
			int keyStart= scanner.getCurrentTokenStartPosition();
			int keyEnd= scanner.getCurrentTokenEndPosition();
			if (scanner.getNextToken() == ITerminalSymbols.TokenNameLPAREN) {
				if (scanner.getNextToken() != ITerminalSymbols.TokenNameStringLiteral)
					return null;
				keyStart= scanner.getCurrentTokenStartPosition() + 1;
				keyEnd= scanner.getCurrentTokenEndPosition();
				keyPositionResult.setOffset(keyStart);
				keyPositionResult.setLength(keyEnd - keyStart);
				return source.substring(keyStart, keyEnd);
			} else {
				keyPositionResult.setOffset(keyStart);
				keyPositionResult.setLength(keyEnd - keyStart + 1);
				return src;
			}
		} catch (InvalidInputException e) {
			return null;
		}
	}

	/** 
	* Finds the start position in the property file. We assume that the key is the first match on a line.
	* @param propertyName the property name
	* @return	the start position of the property name in the file, -1 if not found
	*/
	private int findPropertyNameStartPosition(String propertyName) {
		InputStream stream= null;
		LineReader lineReader= null;
		String encoding;
		try {
			encoding= fPropertiesFile.getCharset();
		} catch (CoreException e1) {
			encoding= "ISO-8859-1";
		}
		try {
			stream= createInputStream(fPropertiesFile);
			lineReader= new LineReader(stream, encoding);
		} catch (CoreException cex) {
			JavaPlugin.log(cex);
			return -1;
		} catch (IOException e) {
			if (stream != null) {
				try {
					stream.close();
				} catch (IOException ce) {
					JavaPlugin.log(ce);
				}
			}
			return -1;
		}
		int start= 0;
		try {
			StringBuffer buf= new StringBuffer(80);
			int eols= lineReader.readLine(buf);
			int keyLength= propertyName.length();
			while (eols > 0) {
				String line= buf.toString();
				int i= line.indexOf(propertyName);
				int charPos= i + keyLength;
				char terminatorChar= 0;
				boolean hasNoValue= (charPos >= line.length());
				if (i > -1 && !hasNoValue)
					terminatorChar= line.charAt(charPos);
				if (line.trim().startsWith(propertyName) && (hasNoValue || Character.isWhitespace(terminatorChar) || terminatorChar == '=')) {
					start+= line.indexOf(propertyName);
					eols= -17;
				} else {
					start+= line.length() + eols;
					buf.setLength(0);
					eols= lineReader.readLine(buf);
				}
			}
			if (eols != -17)
				start= -1;
		} catch (IOException ex) {
			JavaPlugin.log(ex);
			return -1;
		} finally {
			try {
				lineReader.close();
			} catch (IOException ex) {
				JavaPlugin.log(ex);
			}
		}
		return start;
	}

	private void loadProperties() {
		Set duplicateKeys= new HashSet();
		fProperties= new Properties(duplicateKeys);
		InputStream stream;
		try {
			stream= new BufferedInputStream(createInputStream(fPropertiesFile));
		} catch (CoreException ex) {
			fProperties= new Properties();
			return;
		}
		try {
			fProperties.load(stream);
		} catch (IOException ex) {
			fProperties= new Properties();
			return;
		} finally {
			try {
				stream.close();
			} catch (IOException ex) {
			}
			reportDuplicateKeys(duplicateKeys);
		}
	}

	private InputStream createInputStream(IFile propertiesFile) throws CoreException {
		ITextFileBufferManager manager= FileBuffers.getTextFileBufferManager();
		if (manager != null) {
			ITextFileBuffer buffer= manager.getTextFileBuffer(propertiesFile.getFullPath(), LocationKind.IFILE);
			if (buffer != null) {
				return new ByteArrayInputStream(buffer.getDocument().get().getBytes());
			}
		}
		return propertiesFile.getContents();
	}

	private void reportDuplicateKeys(Set duplicateKeys) {
		if (duplicateKeys.size() == 0)
			return;
		FileEntry groupElement= new FileEntry(fPropertiesFile, NLSSearchMessages.NLSSearchResultCollector_duplicateKeys);
		Iterator iter= duplicateKeys.iterator();
		while (iter.hasNext()) {
			String propertyName= (String)iter.next();
			addMatch(groupElement, propertyName);
		}
		fResult.addFileEntryGroup(groupElement);
	}
}
